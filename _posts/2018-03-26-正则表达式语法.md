---
title: 正则表达式语法
date: 2018-3-26 15:17:48
categories:
- tech
---

整理正则表达式的语法和实例。

<!-- more -->

## 语法

### 元字符

| 字符           | 描述                                       |
| ------------ | ---------------------------------------- |
| \            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“`n`”匹配字符“`n`”。“`\n`”匹配一个换行符。串行“`\\`”匹配“`\`”而“`\(`”则匹配“`(`”。 |
| ^            | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“`\n`”或“`\r`”之后的位置。 |
| $            | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“`\n`”或“`\r`”之前的位置。 |
| *            | 匹配前面的子表达式零次或多次。例如，zo*能匹配“`z`”以及“`zoo`”。*等价于{0,}。 |
| +            | 匹配前面的子表达式一次或多次。例如，“`zo+`”能匹配“`zo`”以及“`zoo`”，但不能匹配“`z`”。+等价于{1,}。 |
| ?            | 匹配前面的子表达式零次或一次。例如，“`do(es)?`”可以匹配“`does`”或“`does`”中的“`do`”。?等价于{0,1}。 |
| {n}          | n是一个非负整数。匹配确定的n次。例如，“`o{2}`”不能匹配“`Bob`”中的“`o`”，但是能匹配“`food`”中的两个o。 |
| {n,}         | n是一个非负整数。至少匹配n次。例如，“`o{2,}`”不能匹配“`Bob`”中的“`o`”，但能匹配“`foooood`”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o*`”。 |
| {n,m}        | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“`o{1,3}`”将匹配“`fooooood`”中的前三个o。“`o{0,1}`”等价于“`o?`”。请注意在逗号和两个数之间不能有空格。 |
| ?            | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“`oooo`”，“`o+?`”将匹配单个“`o`”，而“`o+`”将匹配所有“`o`”。 |
| .            | 匹配除“`\``n`”之外的任何单个字符。要匹配包括“`\``n`”在内的任何字符，请使用像“`(.|\n)`”的模式。 |
| (pattern)    | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“`\(`”或“`\)`”。 |
| (?:pattern)  | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(|)`”来组合一个模式的各个部分是很有用。例如“`industr(?:y|ies)`”就是一个比“`industry|industries`”更简略的表达式。 |
| (?=pattern)  | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95|98|NT|2000)`”能匹配“`Windows2000`”中的“`Windows`”，但不能匹配“`Windows3.1`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)  | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95|98|NT|2000)`”能匹配“`Windows3.1`”中的“`Windows`”，但不能匹配“`Windows2000`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
| (?<=pattern) | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?<=95|98|NT|2000)Windows`”能匹配“`2000Windows`”中的“`Windows`”，但不能匹配“`3.1Windows`”中的“`Windows`”。 |
| (?<!pattern) | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?<!95|98|NT|2000)Windows`”能匹配“`3.1Windows`”中的“`Windows`”，但不能匹配“`2000Windows`”中的“`Windows`”。 |
| x\|y         | 匹配x或y。例如，“`z|food`”能匹配“`z`”或“`food`”。“`(z|f)ood`”则匹配“`zood`”或“`food`”。 |
| [xyz]        | 字符集合。匹配所包含的任意一个字符。例如，“`[abc]`”可以匹配“`plain`”中的“`a`”。 |
| [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如，“`[^abc]`”可以匹配“`plain`”中的“`p`”。 |
| [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，“`[a-z]`”可以匹配“`a`”到“`z`”范围内的任意小写字母字符。 |
| [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“`[^a-z]`”可以匹配任何不在“`a`”到“`z`”范围内的任意字符。 |
| \b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“`er\b`”可以匹配“`never`”中的“`er`”，但不能匹配“`verb`”中的“`er`”。 |
| \B           | 匹配非单词边界。“`er\B`”能匹配“`verb`”中的“`er`”，但不能匹配“`never`”中的“`er`”。 |
| \cx          | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“`c`”字符。 |
| \d           | 匹配一个数字字符。等价于`[0-9]`。                     |
| \D           | 匹配一个非数字字符。等价于`[^0-9]`。                   |
| \f           | 匹配一个换页符。等价于\x0c和\cL。                     |
| \n           | 匹配一个换行符。等价于\x0a和\cJ。                     |
| \r           | 匹配一个回车符。等价于\x0d和\cM。                     |
| \s           | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
| \S           | 匹配任何非空白字符。等价于`[^ \f\n\r\t\v]`。           |
| \t           | 匹配一个制表符。等价于\x09和\cI。                     |
| \v           | 匹配一个垂直制表符。等价于\x0b和\cK。                   |
| \w           | 匹配包括下划线的任何单词字符。等价于“`[A-Za-z0-9_]`”。      |
| \W           | 匹配任何非单词字符。等价于“`[^A-Za-z0-9_]`”。          |
| \xn          | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“`\x41`”匹配“`A`”。“`\x041`”则等价于“`\x04&1`”。正则表达式中可以使用ASCII编码。. |
| \num         | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“`(.)\1`”匹配两个连续的相同字符。 |
| \n           | 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
| \nm          | 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 |
| \nml         | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |
| \un          | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 |

### 运算符优先级

| 运算符                       | 描述                                       |
| ------------------------- | ---------------------------------------- |
| \                         | 转义符                                      |
| (), (?:), (?=), []        | 圆括号和方括号                                  |
| *, +, ?, {n}, {n,}, {n,m} | 限定符                                      |
| ^, $, \任何元字符、任何字符         | 定位点和序列（即：位置和顺序）                          |
| \|                        | 替换，"或"操作字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |

### 匹配规则

#### 基本模式匹配

一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：

```
^once
```

这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串"once upon a time"匹配，与"There once was a man from NewYork"不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。

```
bucket$
```

这个模式与"Who kept all of this cash in a bucket"匹配，与"buckets"不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：

```
^bucket$
```

只匹配字符串"bucket"。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式

```
once
```

与字符串

```
There once was a man from NewYork
Who kept all of his cash in a bucket.
```

是匹配的。

在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠(\)打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：

```
^\t 
```

类似的，用\n表示"新行"，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\\表示，句号.用\.表示，以此类推。

#### 字符簇

在INTERNET的程序中，正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。

所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：

```
[AaEeIiOoUu]
```

这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：

```
[a-z] //匹配所有的小写字母 
[A-Z] //匹配所有的大写字母 
[a-zA-Z] //匹配所有的字母 
[0-9] //匹配所有的数字 
[0-9\.\-] //匹配所有的数字，句号和减号 
[ \f\r\t\n] //匹配所有的白字符
```

同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如"z2"、"t6"或"g7"，但不是"ab2"、"r2d3" 或"b52"的话，用这个模式：

```
^[a-z][0-9]$
```

尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。

前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示"非"或"排除"的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：

```
^[^0-9][0-9]$
```

这个模式与"&5"、"g7"及"-2"是匹配的，但与"12"、"66"是不匹配的。下面是几个排除特定字符的例子：

```
[^a-z] //除了小写字母以外的所有字符 
[^\\\/\^] //除了(\)(/)(^)之外的所有字符 
[^\"\'] //除了双引号(")和单引号(')之外的所有字符
```

特殊字符"." (点，句号)在正则表达式中用来表示除了"新行"之外的所有字符。所以模式"^.5$"与任何两个字符的、以数字5结尾和以其他非"新行"字符开头的字符串匹配。模式"."可以匹配任何字符串，除了空串和只包括一个"新行"的字符串。

PHP的正则表达式有一些内置的通用字符簇，列表如下：

| 字符簇          | 描述                       |
| ------------ | ------------------------ |
| [[:alpha:]]  | 任何字母                     |
| [[:digit:]]  | 任何数字                     |
| [[:alnum:]]  | 任何字母和数字                  |
| [[:space:]]  | 任何空白字符                   |
| [[:upper:]]  | 任何大写字母                   |
| [[:lower:]]  | 任何小写字母                   |
| [[:punct:]]  | 任何标点符号                   |
| [[:xdigit:]] | 任何16进制的数字，相当于[0-9a-fA-F] |

#### 确定重复出现

到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。

| 字符簇              | 描述                       |
| ---------------- | ------------------------ |
| ^[a-zA-Z_]$      | 所有的字母和下划线                |
| ^[[:alpha:]]{3}$ | 所有的3个字母的单词               |
| ^a$              | 字母a                      |
| ^a{4}$           | aaaa                     |
| ^a{2,4}$         | aa,aaa或aaaa              |
| ^a{1,3}$         | a,aa或aaa                 |
| ^a{2,}$          | 包含多于两个a的字符串              |
| ^a{2,}           | 如：aardvark和aaab，但apple不行 |
| a{2,}            | 如：baad和aaa，但Nantucket不行  |
| \t{2}            | 两个制表符                    |
| .{2}             | 所有的两个字符                  |

这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是**前面的字符或字符簇只出现x次** ；一个数字加逗号 {x,} 的意思是**前面的内容出现x或更多的次数** ；两个数字用逗号分隔的数字 {x,y} 表示 **前面的内容至少出现x次，但不超过y次**。我们可以把模式扩展到更多的单词或数字：

```
^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]{0,}$        // 所有的正整数 
^\-{0,1}[0-9]{1,}$      // 所有的整数 
^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
```

最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(\.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。

特殊字符 ? 与 {0,1} 是相等的，它们都代表着： **0个或1个前面的内容** 或 **前面的内容是可选的** 。所以刚才的例子可以简化为：

```
^\-?[0-9]{1,}\.?[0-9]{1,}$
```

特殊字符 * 与 {0,} 是相等的，它们都代表着 **0 个或多个前面的内容** 。最后，字符 + 与 {1,} 是相等的，表示 **1 个或多个前面的内容** ，所以上面的4个例子可以写成：

```
^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]*$        // 所有的正整数 
^\-?[0-9]+$          // 所有的整数 
^\-?[0-9]+\.?[0-9]*$ // 所有的浮点数
```

当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。

#### 断言

##### 零宽断言
零宽断言，大多地方这样定义它，用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像 \b ^ $ \< > 这样的锚定作用，用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。我的理解是**在一个限定位置的字符串之前或之后进行匹配查找**。所以零宽断言，执行过程分两种情况，如果是正向断言，应该是这样的，第一步，判断判断断言是否为真（即是否满足一定条件）第二步，如果满足条件，则进行下一步查找匹配。如果是反向断言，第一步还是按照正则表达式顺序去匹配。第二步，遇到反向代言，判断是否满足反向代言。


##### 正先行断言

什么是正先行断言，就是在字符串相应位置之前进行查找匹配，使用   (?=exp) 匹配exp前面的位置。 
实例

```
$str="abcgwcab";
$parent='/bc(?=gw)/';
$str=preg_match($parent,$str,$match);
var_dump($match);
/**
输出结果：
int 1
array (size=1) 
    0 => string 'bc' (length=2)
    */12345678910
```

解析：首先查找字符串”abcgwcab”中gw位置，断言为真，然后在匹配bc。如果将正则表达式写成`$parent='/bc(?=gw)ca/';` 将会匹配不成功。

##### 反先行断言

什么是反先行断言，使用 (?!exp) 匹配后面跟的不是exp。 
实例：

```
$str="abcgwcab";
$parent='/bc(?!ww)gw/';
$str=preg_match($parent,$str,$match);
var_dump($str);
var_dump($match);
/**
输出：
int 1
array (size=1)
  0 => string 'bcgw' (length=4)
*/1234567891011
```

解析：首先判断字符串是否包含bc，然后判断其后面不是ww,最后匹配gw。可以看出反向断言之前后之后，能够在添加其他匹配条件。

##### 正后发断言

什么是正后发断言，就是在字符串相应位置之后进行查找匹配， (?<=exp) 匹配exp后面的位置 
实例：

```
$str="abcgwcab";
$parent='/(?<=gw)ca/';
$str=preg_match($parent,$str,$match);
var_dump($str);
var_dump($match);
/**
输出结果：
int 1
array (size=1)
  0 => string 'ca' (length=2)
*/1234567891011
```

解析：第一步，查找字符”abcgwcab”中是否包含有gw，返回结果为true，然后进行第二步，查找gw后面是否有ca。

##### 反后发断言

什么是反后发断言，使用(?

```
$str="abcgwcab";
$parent='/(?<!bc)gw/';
$str=preg_match($parent,$str,$match);
var_dump($str);
var_dump($match);
/**
int 0
array (size=0)
  empty
*/12345678910
```

解析：首先在字符串中匹配gw，然后判断其前面是不是bc，发现其前面是bc，故返回false。

##### 练习题

例1：`\d+(?=abc)` 
判断一个字符串中是否包含’abc’，且其前面是否包含一个或多个数字 
例2：`(?<=\d\d)\w` 
判断字符串中是否存在连续两个数字，且其后面包含一个字母 
例3：`\d{3} (?!55)` 
判断字符串中是否包含连续三个数字，且三个数字后面不是55 
例4：`(?<!ac)\w\d` 
判断一个字符串是否包含一个字母加数字的组合，且其前面不是ac

##### 总结

先行断言与后发断言区别？ 
先行断言是判断断言之前的正则表达式，断言在其他正则表达式之后。后发断言是判断断言之前的正则表达式，断言在其他正则表达式之前。这里的先与后，是其他匹配相对应断言在正则表达式中的顺序。



## 实例

### 常用实例

| 描述              | 表达式                                      |
| --------------- | ---------------------------------------- |
| 用户名             | `/^[a-z0-9_-]{3,16}$/`                   |
| 密码              | `/^[a-z0-9_-]{6,18}$/`                   |
| 十六进制值           | `/^#?([a-f0-9]{6}\|[a-f0-9]{3})$/`       |
| 电子邮箱            | `/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})` |
| URL             | `/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/` |
| IP 地址           | `/((2[0-4]\d\|25[0-5]\|[01]?\d\d?)\.){3}(2[0-4]\d\|25[0-5]\|[01]?\d\d?)//^(?:(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)$/` |
| HTML 标签         | `/^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>\|\s+\/>)$/` |
| 删除代码\\注释        | `(?<!http:\|\S)//.*$`                    |
| Unicode编码中的汉字范围 | `/^[\u2E80-\u9FFF]+$/`                   |

### 复杂实例

#### 提取所有a标签中的链接： `.*href=\"(.*?)\"`

```
<a href="https://www.baidu.com/">百度</a>
<a href="https://www.google.com/">谷歌</a>
```





## 在线测试

[http://tool.oschina.net/regex/](http://tool.oschina.net/regex/)

[https://c.runoob.com/front-end/854](https://c.runoob.com/front-end/854)

[https://www.sojson.com/regex/](https://www.sojson.com/regex/)

[https://tool.lu/regex/](https://tool.lu/regex/)

## 参考资料

[正则表达式手册](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)

[正则表达式 - 教程](http://www.runoob.com/regexp/regexp-tutorial.html)

## 