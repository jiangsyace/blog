---
title: Java知识总结
date: 2018-10-30 19:52:15
categories:
- tech
tags:
- java
---

Java知识总结

<!-- more -->


## 一、基础知识


### 数据类型

1. 基本数据类型：byte、short、int、long、float、double、char、boolean
2. 引用数据类型：数组，对象

### 基本语法

**变量名**

1. 必须以字母、下划线“_”、或“$”符号开头
2. 可以包括数字、区分大小写
3. 不能使用关键字，例如int、class、public等

**变量类型**

+ 类变量：独立于方法和语句块之外的变量。
  + 类变量也称为静态变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外。
  + 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
  + 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。
  + 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
  + 静态变量在第一次被访问时创建，在程序结束时销毁。
  + 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
  + 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
  + 静态变量可以通过：*ClassName.VariableName*的方式访问。
  + 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。
+ 实例变量：独立于方法之外的变量。
  + 实例变量也叫成员变量，声明在一个类中，但在方法、构造方法和语句块之外；
  + 当一个对象被实例化之后，每个实例变量的值就跟着确定；
  + 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
  + 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
  + 实例变量可以声明在使用前或者使用后；
  + 访问修饰符可以修饰实例变量；
  + 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
  + 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
  + 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。
+ 局部变量：类的方法中的变量。
  + 局部变量声明在方法、构造方法或者语句块中；
  + 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
  + 访问修饰符不能用于局部变量；
  + 局部变量只在声明它的方法、构造方法或者语句块中可见；
  + 局部变量是在栈上分配的。
  + 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

**作用域和生命周期：**

+ 作用域：在定义的范围内有效。从变量定义的位置开始，到该变量所在的那对大括号结束；

+ 生命周期：
    + 静态变量位于方法区，生命周期取决于类的生命周期（类何时被加载及卸载）。
    + 实例变量位于堆区，生命周期取决于实例的生命周期（实例何时被创建及销毁）。
    + 局部变量位于栈区，生命周期取决于所属的方法何时被调用及结束调用。

+ 区别：作用域是对象起作用的地方,生命周期对象生存的时段,就JAVA来说,对象不被引用了也就OVER了。即生命周期定义的是时间，作用域定义的是空间。

**对象和类 ：**

主函数：主函数是程序的入口，被JVM调用。如果该类不需要独立运行，主函数是不用定义的。

构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。

特点：

1：该函数的名称和所在类的名称相同。

2：不需要定义返回值类型。

3：该函数没有具体的返回值。

记住：所有对象创建时，都需要初始化才可以使用。

注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。

一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。

构造代码块和构造函数有什么区别？

构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。

构造函数：是给与之对应的对象进行初始化。它具有针对性。

执行顺序：（优先级从高到低。）静态代码块>mian方法>构造代码块>构造方法。其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。
静态代码块的作用：比如我们在调用C语言的动态库时会可把.so文件放在此处。 
构造代码块的功能：（可以把不同构造方法中相同的共性的东西写在它里面）。例如：比如不论任何机型的电脑都有开机这个功能，此时我们就可以把这个功能定义在构造代码块内。

匿名对象使用场景：

1：当对方法只进行一次调用的时候，可以使用匿名对象。

2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。


**运算符优先级**


### 面向对象

接口和抽象类

[深入理解Java的接口和抽象类](https://www.cnblogs.com/dolphin0520/p/3811437.html)

围绕着 Java 类和 Java 对象，有三大基本特性：封装是 Java 类的编写规范、继承是类与类之间联系的一种形式、而多态为系统组件或模块之间解耦提供了解决方案。

[Java面向对象概述和三大特性](https://www.cnblogs.com/xugf/p/8475931.html)

1. 封装

2. 继 承

3. 多 态

### 常用类

**String**

1. String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。

2. String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。 

3. String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。

4. 字符串的”+“操作实际上也是先创建一个StringBuffer对象，然后调用append()方法将字符串片段拼接起来，最后调用toString()方法转换为字符串

总结
   线程安全：

   -  StringBuffer：线程安全
   -  StringBuilder：线程不安全

   速度： 一般情况下，速度从快到慢为 StringBuilder > StringBuffer > String，当然这是相对的，不是绝对的。

6. 使用环境：

   -  操作少量的数据使用 String；
   -  单线程操作大量数据使用 StringBuilder；
   -  多线程操作大量数据使用 StringBuffer。

+ Stringbuffer的线程安全是怎么实现的？

+ 直接通过synchronized 关键字来实现append方法的同步操作

**Date**

1. Calender的月份是从0开始的，但日期和年份是从1开始的
2. 判断闰年：`year%4==0&&year%100!=0||year%400==0`
   1. 能被4整除，并且不能被100整除或者能被400整除。
   2. 

+ 

### 内存与JVM

[Java内存区域与内存溢出异常](http://wustrive2008.github.io/2015/12/24/java/深入理解jvm之内存区域与内存溢出/)

1. JVM参数
2. 内存分配机制
3. 内存回收(GC)
4. 内存泄漏与监控

## Java内存区域与内存溢出异常

### 运行时数据区域

#### 程序计数器

- 当前线程所执行的字节码的行号指示器
- 当前线程私有
- 不会出现OutOfMemoryError情况

#### java虚拟机栈

- 线程私有，生命周期与线程相同
- java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，存储局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息
- StackOverflowError异常：当线程请求的栈深度大于虚拟机所允许的深度
- OutOfMemoryError异常：如果栈的扩展时无法申请到足够的内存

#### 本地方法栈

与虚拟机栈相似，主要为虚拟机使用到的Native方法服务，在HotSpot虚拟机中直接把本地方法栈与虚拟机栈二合一

#### Java堆(Java Heap)

java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存储对象实例。java堆是垃圾收集器管理的主要区域。java堆还可以细分为：新生代与老年代。在细一点有Eden空间、Form  Survivor空间、To Survivor空间等。

- 可以通过-Xmx和-Xms控制堆的大小
- OutOfMemoryError异常：当在堆中没有内存完成实例分配，且堆也无法再扩展时。

#### 方法区

- 线程间共享
- 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- OutOfMemoryError异常：当方法区无法满足内存的分配需求时

#### 运行时常量池

- 方法区的一部分
- 用于存放编译期生成的各种字面量与符号引用
- OutOfMemoryError异常：当常量池无法再申请到内存时

#### 直接内存

- NIO可以使用Native函数库直接分配堆外内存，堆中的DirectByteBuffer对象作为这块内存的引用进行操作
- 大小不受Java堆大小的限制，受本机(服务器)内存限制
- OutOfMemoryError异常：系统内存不足时

### HotSpot虚拟机

#### 对象的创建

虚拟机遇到一条new指令时，首先将去检查这个对象的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行类的加载过程。
在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存大小再类加载完成后便可确定。内存分配可以采用“指针碰撞”与“空闲列表”的方式。

#### 对象的访问定位

java程序需要通过栈上的reference数据来操作堆上的具体对象。访问方式有使用句柄和直接指针两种。

- 句柄访问 java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
- 直接指针访问 java堆对象的布局中必须考虑如何放置访问类型数据的相关信息，reference中存储的就是对象地址

### OOM异常的解决思路

生成Dump快照文件：

- 通过jvm参数—XX:-HeapDumpOnOutOfMemoryError可以让JVM在出现内存溢出是Dump出当前的内存转储快照
- 用jmap生产dump文件，win通过任务管理器查看tomcat的进程pid，linux用ps命令查看进程pid,然后用jmap命令

先通过内存映像分析工具(如Eclipse的Memory Analyzer)进行分析，常见的情况有：

- 内存泄露，对象已经死了，无法通过垃圾收集器进行自动回收，通过找出泄露的代码位置和原因，才好确定解决方案；
- 内存溢出，内存中的对象都还必须存活着，这说明Java堆分配空间不足，检查堆设置大小（-Xmx与-Xms），检查代码是否存在对象生命周期太长、持有状态时间过长的情况。

## 二、数据结构与算法

### 数据结构
1. 线性结构
2. 树形结构
3. 图

### 算法
1. 搜索算法
2. 排序算法 
3. 集合 

4. Map
4.1. HashMap和Hashtable的区别

Hashtable是基于陈旧的Dictionary的Map接口的实现，而HashMap是基于哈希表的Map接口的实现
从方法上看，HashMap去掉了Hashtable的contains方法
HashTable是同步的(线程安全)，而HashMap线程不安全，效率上HashMap更快
HashMap允许空键值，而Hashtable不允许
HashMap的iterator迭代器执行快速失败机制，也就是说在迭代过程中修改集合结构，除非调用迭代器自身的remove方法，否则以其他任何方式的修改都将抛出并发修改异常。而Hashtable返回的Enumeration不是快速失败的。

5. List

1. ArrayList
    无参构造，默认初始容量是10。当向ArrayList中添加对象的时候，原对象的数目加1如果大于原底层数组长度的时候ArrayList会进行自动扩容。  
    自动扩容：其实是size的一个增加，当现有长度满足不了新数组的长度时所依据java的内部机制进行的扩容。这个过程是新建一个原数组并对原数组进行修改，指定这个新建数组。原数组通过JVM自动进行处理。  
    ArrayList(Collections<?extends E> c)构造包含指定collection的元素的列表
    ArrayList(int initialCapacity) 指定初始容量

**拓展：**  
当新建数组长度大于size所能够自动扩容的最大长度时应当如何处理？  
一般在开发中你是如何确定你所要定义的容量的，你一般定义多少呢？  

参考链接：[Java中的ArrayList的初始容量和容量分配](https://www.cnblogs.com/ShanHeDiao/p/4402030.html)

3. List集合和Set集合

List中元素存取是有序的、可重复的；Set集合中元素是无序的，不可重复的。

CopyOnWriteArrayList:COW的策略，即写时复制的策略。适用于读多写少的并发场景

Set集合元素存取无序，且元素不可重复。

HashSet不保证迭代顺序，线程不安全；LinkedHashSet是Set接口的哈希表和链接列表的实现，保证迭代顺序，线程不安全。

TreeSet：可以对Set集合中的元素排序，元素以二叉树形式存放，线程不安全。

3.1 ArrayList、LinkedList、Vector的区别

首先它们均是List接口的实现。

ArrayList、LinkedList的区别

1.随机存取：ArrayList是基于可变大小的数组实现，LinkedList是链接列表的实现。这也就决定了对于随机访问的get和set的操作，ArrayList要优于LinkedList，因为LinkedList要移动指针。

2.插入和删除：LinkedList要好一些，因为ArrayList要移动数据，更新索引。

3.内存消耗：LinkedList需要更多的内存，因为需要维护指向后继结点的指针。

Vector从JDK 1.0起就存在，在1.2时改为实现List接口，功能与ArrayList类似，但是Vector具备线程安全。

3.3 Map集合

Hashtable:基于Dictionary类，线程安全，速度快。底层是哈希表数据结构。是同步的。 不允许null作为键，null作为值。

Properties:Hashtable的子类。用于配置文件的定义和操作，使用频率非常高，同时键和值都是字符串。

HashMap：线程不安全，底层是数组加链表实现的哈希表。允许null作为键，null作为值。HashMap去掉了contains方法。 注意：HashMap不保证元素的迭代顺序。如果需要元素存取有序，请使用LinkedHashMap

TreeMap：可以用来对Map集合中的键进行排序。

ConcurrentHashMap:是JUC包下的一个并发集合。

3.4 为什么使用ConcurrentHashMap而不是HashMap或Hashtable？

HashMap的缺点：主要是多线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会死循环，CPU达到100%，所以在并发情况下不能使用HashMap。让HashMap同步：Map m = Collections.synchronizeMap(hashMap);而Hashtable虽然是同步的，使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。

ConcurrentHashMap的原理：

HashTable容器在竞争激烈的并发环境下表现出效率低下的原因在于所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

ConcurrentHashMap的结构：

ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入互斥锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，当对某个HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。

ConcurrentHashMap的构造、get、put操作：

构造函数：传入参数分别为 1、初始容量，默认16 2、装载因子 装载因子用于rehash的判定，就是当ConcurrentHashMap中的元素大于装载因子*最大容量时进行扩容，默认0.75 3、并发级别 这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16;。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。默认16.

初始化的一些动作：

初始化segments数组（根据并发级别得到数组大小ssize），默认16

初始化segmentShift和segmentMask（这两个全局变量在定位segment时的哈希算法里需要使用），默认情况下segmentShift为28，segmentMask为15

初始化每个Segment，这一步会确定Segment里HashEntry数组的长度.

put操作：

1、判断value是否为null，如果为null，直接抛出异常。

2、key通过一次hash运算得到一个hash值。将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&运算得到segment的索引j。即segmentFor方法

3、使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&运算获取HashEntry的索引，然后set）。

get操作：

1、和put操作一样，先通过key进行hash确定应该去哪个Segment中取数据。

2、使用Unsafe获取对应的Segment，然后再进行一次&运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。

定位Segment的hash算法：(hash >>> segmentShift) & segmentMask

定位HashEntry所使用的hash算法：int index = hash & (tab.length - 1);

注：


2.ConcurrentHashMap既不允许null key也不允许null value

3.5 Collection 和 Collections的区别

Collection是集合类的上级接口，子接口主要有Set 和List、Queue Collections是针对集合类的一个辅助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

3.6 Map、Set、List、Queue、Stack的特点与用法

Set集合类似于一个罐子，"丢进"Set集合里的多个对象之间没有明显的顺序。 List集合代表元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。 Stack是Vector提供的一个子类，用于模拟"栈"这种数据结构(LIFO后进先出) Queue用于模拟"队列"这种数据结构(先进先出 FIFO)。 Map用于保存具有"映射关系"的数据，因此Map集合里保存着两组值。

3.7 HashMap的工作原理

HashMap维护了一个Entry数组，Entry内部类有key,value，hash和next四个字段，其中next也是一个Entry类型。可以将Entry数组理解为一个个的散列桶。每一个桶实际上是一个单链表。当执行put操作时，会根据key的hashcode定位到相应的桶。遍历单链表检查该key是否已经存在，如果存在，覆盖该value，反之，新建一个新的Entry，并放在单链表的头部。当通过传递key调用get方法时，它再次使用key.hashCode()来找到相应的散列桶，然后使用key.equals()方法找出单链表中正确的Entry，然后返回它的值。

3.8 Map的实现类的介绍

HashMap基于散列表来的实现，即使用hashCode()进行快速查询元素的位置，显著提高性能。插入和查询“键值对”的开销是固定的。可以通过设置容量和装载因子，以调整容器的性能。

LinkedHashMap, 类似于HashMap,但是迭代遍历它时，保证迭代的顺序是其插入的次序，因为它使用链表维护内部次序。此外可以在构造器中设定LinkedHashMap，使之采用LRU算法。使没有被访问过的元素或较少访问的元素出现在前面，访问过的或访问多的出现在后面。这对于需要定期清理元素以节省空间的程序员来说，此功能使得程序员很容易得以实现。

TreeMap, 是基于红黑树的实现。同时TreeMap实现了SortedMap接口，该接口可以确保键处于排序状态。所以查看“键”和“键值对”时，所有得到的结果都是经过排序的，次序由自然排序或提供的Comparator决定。SortedMap接口拥有其他额外的功能，如：返回当前Map使用的Comparator比较强，firstKey()，lastKey(),headMap(toKey),tailMap(fromKey)以及可以返回一个子树的subMap()方法等。

WeakHashMap，表示弱键映射，WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。

ConcurrentHashMap， 在HashMap基础上分段锁机制实现的线程安全的HashMap。

IdentityHashMap 使用==代替equals() 对“键”进行比较的散列映射。专为解决特殊问题而设计。

HashTable：基于Dictionary类的Map接口的实现，它是线程安全的。

3.9 LinkedList 和 PriorityQueue 的区别

它们均是Queue接口的实现。拥有FIFO的特点，它们的区别在于排序行为。LinkedList 支持双向列表操作， PriorityQueue 按优先级组织的队列，元素的出队次序由元素的自然排序或者由Comparator比较器指定。





## 三、设计模式

1. 原则
2. 创建模式
3. 结构模式
4. 行为模式

## 四、I/O与网络

### 基本IO

1. 文件IO
2. 序列化
3. 网络IO

### 线程与并发

- 线程安全

Vector、Stack、HashTable、ConcurrentHashMap、Properties

### 网络开发

1. 数据结构
2. 通信协议
3. 通信框架

## 五、Java web

从JDK 5.0开始 J2EE 改名为 java EE，J2SE 改名为 java SE，J2ME 改名成 java ME

### 框架

1. 基本MVC
2. Spring体系
   1. spring运行过程，原理
3. Structs
4. hibernate
5. ibatis/mybatis

### 前端



### 缓存



### 编码与加密



## 六、服务器与容器



## 七、数据库(MySQL、Redis等)



## 参考

[http://www.runoob.com/java/java-tutorial.html](http://www.runoob.com/java/java-tutorial.html)

