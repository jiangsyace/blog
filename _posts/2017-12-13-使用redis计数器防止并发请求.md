---
title: 使用redis计数器防止并发请求
categories:
- tech
tags:
- Spring
- Redis
---

大转盘抽奖功能，转盘的并发请求问题。

### 需求描述

大转盘抽奖功能，转盘的并发请求问题：业务需求是需要限制一个用户只能同时发送一次转盘请求。执行抽奖需要的时间很短，具有时效性，如果用数据库存放正在抽奖的用户，每次转盘请求都要查询数据库校验是否正在抽奖，效率很低。

<!-- more -->

### 问题分析

​      转盘抽奖，一开始考虑分布式队列，将所有正在抽奖的用户放到队列中，每次请求检查队列中是否存在，存在则忽略请求，否则执行抽奖。但是这样的话抽奖用户就要从队列读取，又要创建线程池读取队列，还是异步返回结果，麻烦了。


### 使用Redis incr解决问题

> ​      Redis incr 可以实现原子性的递增，可应用于高并发的秒杀活动、分布式序列号生成等场景。这里我使用它来计数实现一分钟内只接受一次请求。

 实现逻辑也很简单：我们在接到短信发送请求后，使用Redis的incr设置一个递增KEY（KEY由固定字符串+手机号码组成），并判断该KEY的数值，如果等于1，说明是第一个请求，我们将该KEY值有效期设置为一分钟；如果该KEY的数值大于1，说明是1分钟内的多次请求，这时我们直接返回短信获取频繁，代码如下：

```
String redisKey = "SMS_LIMIT_" + smsPhone;
long count = redisTemplate.opsForValue().increment(redisKey, 1);
if (count == 1) {
//设置有效期一分钟
  redisTemplate.expire(redisKey, 60, TimeUnit.SECONDS);
}
if (count > 1) {
   resultMap.put("retCode", "-1");     
   resultMap.put("retMsg", "每分钟只能发送一次短信");
   outPrintJson(resultMap);
   return;
}
/** 发送短信 */
......
/** 记录发送日志 */
......
```

### 测试

​      使用Jmeter进行并发测试，同时发送200个线程请求，通过测试发现可避免并发请求问题 ：
[![测试图1](http://img.blog.csdn.net/20160817152711810)](http://img.blog.csdn.net/20160817152711810)
查看结果，只有第一个请求发送了短信，剩余199个请求均返回失败：
[![测试图2](http://img.blog.csdn.net/20160817152824186)](http://img.blog.csdn.net/20160817152824186)
可以看出性能还是很不错的：
[![测试图3](http://img.blog.csdn.net/20160817173432235)](http://img.blog.csdn.net/20160817173432235)