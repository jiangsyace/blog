---
title: MyBatis事物缓存
categories:
- tech
tags:
- jekyll
---

<!-- more -->

## 问题描述

​	定时循环查询数据库中状态，如果状态已更新则跳出循环并执行业务处理，否则一直循环查询直到超时。在第一次查询并打印出查询的sql后，之后的查询都没有打印sql，查询出的结果也一样，即使数据库中状态已经更新。

## 问题分析
​	一开始想到可能是缓存原因引起的，但是没有深入研究mybatis缓存机制，于是尝试禁用二级缓存
```
<!-- 单条sql不使用缓存 -->
<select id="selectUserRoles" resultType="UserRoleVO" flushCache="true" useCache="false">
    select * from user_role a,role b where a.roleid = b.roleid and a.userid = #{userid}
</select>
```
这种方式使用后，每次循环查询都能打印sql，但是查询出的结果仍然一样，没有查询数据库中变更的状态。这种方式不行，要换一种，关闭所有查询的二级缓存，在配置文件中配置`cacheEnable=false`，还是不行。使用Sqlsession主动清除缓存
sessionTemplate.clearCache();不行

会不会是我直接修改数据库没有经过程序修改数据库，没有更新缓存，于是在循环过程中使用程序更新状态值。还是没用，循环过程中一直查询的是同一个状态值。

这也不行

在网上寻找解决方案，看到sql一样，参数一样，可能用到一级缓存（没有仔细研究过mybatis的缓存机制，纯粹为了解决问题）。于是尝试禁用一级缓存。

使用随机数,使上一个查询语句的缓存失效


    (int)Math.random()*1000  
    WHERE #{randomColumn}=${randomColumn}  
> \#{} 表示一个占位符号，通过 #{} 可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换。#{} 可以有效防止   sql注入。 #{} 可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{} 括号中可以是 value 或其它名称。
> \${} 表示拼接sql串，通过 ${} 可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换，不能防止 sql 注入问题， 可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，{} 括号中只能是 value。
> **使用占位符能防止sql注入**




在程序修改状态值后，再次调用服务查询状态，发现马上能查出正确结果，于是怀疑服务上的事务注解导致的缓存




## 解决方案
在方法前加注解 不使用事务

