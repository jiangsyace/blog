---
title: HashMap原理简单认识
date: 2019-7-15
categories:
- tech
tags:
- java
---

HashMap经常使用，但是对原理还是一知半解，整理记录一下，印象会更深刻。

<!-- more -->

### 什么是HashMap?
HashMap是一个基于数组和链表的数据结构。

### 应用场景对比
+ HashMap：实现了Map接口，键唯一，允许null值，非线程安全，效率高
+ HashTable：使用Synchronize关键字保证线程安全，效率低
+ HashSet：实现了Set接口，键不允许null值，不是键值对结构，仅仅是存储不重复的元素，相当于简化版的HashMap，只是包含HashMap中的key而已，HashSet内部就是使用HashMap实现，只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的。
+ ConcurrentHashMap：使用分段锁保证线程安全，效率高

### 源码解析

#### 构造函数

```
/**
 * 指定初始容量和负载因子来构造一个空的HashMap
 * 如果初始容量是负数或者负载因子不是正数，则抛出异常
 */
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                            initialCapacity);
    //初始容量不能超过默认的最大容量(2的幂方中最大值)
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                            loadFactor);

    this.loadFactor = loadFactor;
    threshold = initialCapacity;
    init();
}

/**
 * 指定初始容量和负载因子来构造一个空的HashMap
 * 负载因子使用默认值(0.75).
 */
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
/**
 * 构造一个空的HashMap
 * 初始容量使用默认值(16),负载因子使用默认值(0.75).
 */
public HashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
}
/**
 * 构造一个映射关系与指定Map相同的HashMap
 * 新HashMap使用默认的负载因子(0.75).初始容量经过计算，将指定Map大小增加1/3的容量(除以负载因子0.75)，足以存放指定Map，最小值为默认容量
 */
public HashMap(Map<? extends K, ? extends V> m) {
    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                    DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
    inflateTable(threshold);

    putAllForCreate(m);
}
```
#### get方法

```
public V get(Object key) {
    if (key == null)
        return getForNullKey();
    Entry<K,V> entry = getEntry(key);

    return null == entry ? null : entry.getValue();
}
```

#### remove方法

```
public V remove(Object key) {
    Entry<K,V> e = removeEntryForKey(key);
    return (e == null ? null : e.value);
}
```
#### containsKey方法

```
public boolean containsKey(Object key) {
    return getEntry(key) != null;
}
```
#### containsValue方法

```
public boolean containsValue(Object value) {
    if (value == null)
        return containsNullValue();

    Entry[] tab = table;
    for (int i = 0; i < tab.length ; i++)
        for (Entry e = tab[i] ; e != null ; e = e.next)
            if (value.equals(e.value))
                return true;
    return false;
}
```
#### put方法

```
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size >= threshold) && (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }

    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table = newTable;
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
```



+ 为什么hashMap的容量扩容时一定是2的幂次
+ 
当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断

```
 `HashMap`中`indexFor()`方法中计算`index`是通过位运算(&)来的。
之所以要是2的n次方，是为了能使`indexFor`中的位运算代替取模运算。

/**
 * h为插入元素的hashcode值
 * length为Map的容量
 * &：与操作 比如 1101 & 1011=1001
 * 若length为2的次幂，length-1转化为二进制必定为1111.......，在于h的二进制操作与操作效率非常快，而且不浪费空间。
 * 若length不是2的次幂，例如length为 15，length-1为14转换为二进制为1110，在于h与操作，最后一位都是0，而0011，0101，1001，1011，0111，1101这几个位置永远不能存放元素，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。
 */
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    return h & (length-1);
}
```

### 总结



### 扩展问题
+ 为什么String, Interger这样的wrapper类适合作为键？ 
  + String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。
+ 可以使用自定义的对象作为键吗？ 
  + 当然可使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。
+ 可以使用CocurrentHashMap来代替HashTable吗？
  + HashTable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。

